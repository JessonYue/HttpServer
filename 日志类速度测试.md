# 日志类速度测试
## 日志类实现要点
* 一个包含多个线程的进程最好只写一个文件，这样在分析日志时可以避免在多个文件中跳来跳去。
* 业务线程：干事的线程。  
  日志线程：负责收集日志，并写入日志文件。  
  异步日志：日志线程负责从缓冲区收集日志，并写入日志文件。业务线程除了干事之外只管往缓冲区中写日志。  
* 为什么需要异步日志？  
  因为若是由业务线程直接写入日志文件时，会造成业务线程在进行I/O操作时陷入阻塞状态。这可能造成请求方超时，或者耽误发送心跳消息等。<br>
* 多缓冲技术:前端一块buffer，后端多块buffer，前端buffer满后，和后端一块空闲的buffer交换，然后由日志线程将这块满了的buffer写入日志文件。<br>
* 为什么需要多缓冲？
    * 前端不是将日志一条一条的传给后端，而是将多条日志拼成一个大buffer传给后端，减少了后端被唤醒的频率，降低了开销。<br>
    * 前端写日志时，当buffer满时，不必等待写磁盘操作。<br>
* 为了及时将日志消息写入文件，即便前端buffer没满，每隔一段时间也会进行交换操作。
* 日志打印的消息格式如下：[日期 时间.微秒][日志级别][线程id][源文件名:行号][正文]<br>
  为了加快日志打印速度，其中线程id的打印，和时间戳的的打印需要使用一点小技巧。   
  * 打印线程id前会先查看线程id是否已经缓存过，若缓存过则直接打印，没有缓存过才使用系统调用syscall(SYS_gettid)获取全局唯一的线程id。  
  * 时间戳长这个样子20190511 12:43:05.787868，每次打印时间戳前，会查看当前时刻和上一次打印时间戳的时刻是否处于同一秒内，若处于同一秒内，则只格式化微秒部分；不处于同一秒内才调用gmtime_r格式化时间部分。至于如何判断和上一次打印时间戳是否处于同一秒内，是通过gettimeofday做到的，这个函数可以求得距离1970年0时0分0秒的微妙数。由于gettimeofday不是系统调用，不会陷入内核，所以调用时间相当快。
  
`注：本日志类仅实现高效的多缓冲异步日志系统，不支持日志文件的滚动功能。`
## 测试环境
unbuntu 16.04 VMware Workstation 14 Player
## 测试方式
和muduo的日志库进行对比测试，写入50w条日志，每条日志长度100字节，统计总的写入时间和写入速度。  
* mudo
测试代码：  
```cpp  
#include <stdio.h>
#include<iostream>
#include<muduo/base/Logging.h>
#include<ctime>
using namespace std;
using namespace muduo;

FILE* g_file;

void dummyOutput(const char* msg, int len)
{
	if (g_file)
	{
		fwrite(msg, 1, len, g_file);
	}
}

void dummyFlush()
{
	fflush(g_file);
}

int main()
{
	g_file = ::fopen("./test.txt", "ae");
	
	Logger::setOutput(dummyOutput);
	Logger::setFlush(dummyFlush);
	cout << "len:"<< strlen("20190510 12:09:47.579382Z 100056 INFO  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx - main.cpp:143")<<endl;
	clock_t start, end;
	start = clock();
	for (int i = 0; i < 500000; i++)
	{
		LOG_INFO << "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
	}
	end = clock();
	double endTime = (double)(end - start) / CLOCKS_PER_SEC;
	double totaltime = endTime * 1000;
	double mBytes = 500000 * 100 / 1024 / 1024;
	double mBytesEachSecond = (mBytes / totaltime) * 1000;
	cout <<"muduo  -"<<"Total time:" << totaltime << "ms" << "|" << "Bytes:" << mBytes << "MB" << "|" << "Rate:" << mBytesEachSecond << "MB/s" << endl;
	::fclose(g_file);
	return 0;
}
```
* HttpServer 
测试代码：  
```cpp
#include<iostream>
#include"base/Logger.h"
#include<ctime>
int main()
{
	Logger::getLogger()->start(true);

	clock_t start, end;
	start = clock();
	cout << "len:" << strlen("[20190511 12:43:05.787868][INFO][108616][/home/hanliu/projects/HttpSever/main.cpp:87][xxxxxxxxxxxxx]") << endl;
	for (int i = 0; i < 500000; i++)
	{
		LogInfo("xxxxxxxxxxxxx");
	}
	end = clock();
	double endTime	 = (double)(end - start) / CLOCKS_PER_SEC;
	double totaltime = endTime * 1000;
	double mBytes    = 500000 * 100 / 1024 / 1024;
	double mBytesEachSecond = (mBytes / totaltime) * 1000;
	cout << "mine -"<< "Total time:" << totaltime << "ms" << "|" << "Bytes:" << mBytes << "MB" << "|" << "Rate:" << mBytesEachSecond << "MB/s" << endl;

	Logger::stop();
	return 0;
}
```  
## 测试结果

